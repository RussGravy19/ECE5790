#lang ivy1.7
attribute method = mc

# Enumerated type definitions
type mode_states = {away, wait, bridge}
type signal_states = {green, red}
type output_states = {arrive, leave, none}
type train_names = {e, w}
type m_states = {0,1,2,3}


# Global signal and output vars for component communication
individual e_signal : signal_states
individual w_signal : signal_states
individual e_out : output_states
individual w_out : output_states


# Initialize environment to red lights and trains floating
after init {
   e_signal := red;
   w_signal := red;
   e_out := none;
   w_out := none
}


# Module framework for a train and its environment (state mchn)
module train(name:train_names) = {
   # Internal mode and id names
   individual mode : mode_states
   individual id : train_names

   # initialize to away and give a name
   after init {
      mode := away;
      id := name;
   }

   # fsm A1 for both east and west train
   action a1_env = {
      if(id = e){
         if(mode = away) {
	    if * {
		e_out := arrive;
	    } else {
		e_out := none;
            }
         } else if(mode = bridge) {
	    if * {
		e_out := leave;
	    } else {
		e_out := none;
            }
         } else { # do nothing during wait
            e_out := none;
         }
    
      } else if(id = w){
         if(mode = away) {
	    if * {
		w_out := arrive;
	    } else {
		w_out := none;
            }
         } else if(mode = bridge) {
	    if * {
		w_out := leave;
	    } else {
		w_out := none;
            }
         } else { # do nothing during wait
            w_out := none;
         }
      }
   }    

   # fsm A2 for both east and west train
   action a2_train = {
      if(mode = away){
         if(id = e & e_out = arrive){
	    mode := wait;
	 } else if(id = w & w_out = arrive){
	    mode := wait;
	 }
      } else if(mode = wait){
      	 if(id = e & e_signal = green){
	    mode := bridge;
	 } else if(id = w & w_signal = green){
	    mode := bridge;
	 }
      } else if(mode = bridge){
         if(id = e & e_out = leave){
	    mode := away;
	 } else if(id = w & w_out = leave){
	    mode := away;
	 }
      }
   }
}


# bridge semiphore controller module, only one is needed
object controller = {
   # fairness and safety "near" booleans
   individual e_near : bool
   individual w_near : bool

   # initialize
   after init {
      e_near := false;
      w_near := false;
   }

   # fsm A3 for bridge control
   action a3_ctrl = {
      if(e_out = arrive){ e_near := true; }
      if(e_out = leave){ e_near := false; }
      if(w_out = arrive){ w_near := true; }
      if(w_out = leave){ w_near := false; }

      if(~e_near){ e_signal := red }
      else if(w_signal = red){ e_signal := green }

      if(~w_near){ w_signal := red }
      else if(e_signal = red){w_signal := green}
   }
}


module fair_monitor(name:train_names) = {
   
   individual id:train_names
   individual s:m_states

   after init {
      id := name;
      s := 0;
   }

   action step = {
      if(id = w){
         if(s = 0){
            if(w_out = arrive){ s := 1; }
         } else if(s = 1){
            if(w_signal = green){ s := 0; }
   	    else if(e_out = leave){ s := 2; }
         } else if(s = 2){
	    if(w_signal = green){ s := 0; }
	    else if(e_out = leave){ s := 3; }
	 }
      } else if(id = e){
         if(s = 0){
            if(e_out = arrive){ s := 1; }
         } else if(s = 1){
            if(e_signal = green){ s := 0; }
   	    else if(w_out = leave){ s := 2; }
         } else if(s = 2){
	    if(e_signal = green){ s := 0; }
	    else if(w_out = leave){ s := 3; }
	 }
      }
   }
}


# Create East and West train
instance e_train : train(e)
instance w_train : train(w)

# Create East and West monitor
instance e_mon : fair_monitor(e)
instance w_mon : fair_monitor(w)


# Event for IVy that controls one cycle of system
action event = {
   call e_train.a1_env; # Update trains
   call e_train.a2_train;
   call w_train.a1_env;
   call w_train.a2_train;

   call controller.a3_ctrl; # Update controller

   call e_mon.step;
   call w_mon.step;
}


# Invariant: both trains cannot be on the bridge at once (crash)
# Invariant: neither trains can enter fairness(3)
invariant ~(e_train.mode = bridge & w_train.mode = bridge)
invariant ~(e_mon.s = 3 | w_mon.s = 3) # can only test one invariant at a time

export event
